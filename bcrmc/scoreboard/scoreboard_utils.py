"""Script for reading Minecraft scoreboard data and processing it into dicts to be more Python-ready.
A method is provided in the main Scoreboard class to dump everything to JSON, as well."""
import json
import sys
from pathlib import Path
from typing import Any

from tqdm import tqdm


class Scoreboard:
    """Parses either NBT scoreboard data from a raw `.dat` file or a `.json` file generated by this class into dictionary attributes.
    The scoreboard.dat file is in `world/data/scoreboard.dat`.

    @param data_source: File path to a `.dat` or `.json` file containing scoreboard data.
        Only JSON files structured like the output of this class' `to_json()` method will work.
    @param player_whitelist: Only includes players present in this list.
        Can either be a list of username strings, or a file path to a valid `whitelist.json` file.
        Some datapacks use 'dummy' players to store data, so this can be useful to sort those out.
    @param player_blacklist: Opposite effect of the whitelist parameter.
        Both a whitelist and blacklist cannot be used at the same time.
    @param include_dot_names: Allows player names starting with a dot (.) to be added to the data.
        This is common for Bedrock users joining through something like Geyser.
        It will allow any player names beginning with a dot if whitelisting, but will still exclude the name if blacklisting.
    @param show_progress: Uses a tqdm progress bar to show the progress of the data being read, if `True`.
    """
    def __init__(self,
            data_source: Path | str,
            player_whitelist: list[str] | Path | str='',
            player_blacklist: list[str] | Path | str='',
            include_dot_names: bool = True,
            show_progress: bool = False):
        if player_whitelist and player_blacklist:
            # Raise an error if trying to use a whitelist and a blacklist together.
            # Technically it could work but one would have to take priority, and I can't see
            # many cases where that would realistically be helpful to support.
            raise ValueError('Can\'t use a whitelist and a blacklist at the same time.')
        self.player_whitelist: list = []
        self.player_blacklist: list = []

        if player_whitelist and isinstance(player_whitelist, (Path, str)):
            with open(Path(player_whitelist), 'r', encoding='utf-8') as f:
                whitelist_json = json.load(f)
            for player in whitelist_json:
                # Any bedrock players that connect through geyser or some such will have their name as "unknown" in the whitelist
                # Excluded for safety, just in case
                # In the game, and in the scoreboard, they'll show up as their Java username with a dot in front of it,
                # unfortunately no way to really detect that from this given UUID as far as I'm aware? So we'll just allow
                # any usernames with dots in front of them.
                if not player['uuid'].startswith('00000000-0000-0000-'):
                    self.player_whitelist.append(player['name'])

        if player_blacklist and isinstance(player_blacklist, (Path, str)):
            with open(Path(player_blacklist), 'r', encoding='utf-8') as f:
                blacklist_json = json.load(f)
            for player in blacklist_json:
                self.player_blacklist.append(player['name'])

        # From this point on we should only be using the self. versions, this is just to avoid confusion
        del player_whitelist, player_blacklist

        self.teams:         dict[str, dict[str, Any]] = {}
        self.objectives:    dict[str, dict[str, Any]] = {}
        self.player_scores: dict[str, dict[str, int]] = {}
        self.display_slots: dict[str, str]            = {}

        if Path(data_source).suffix == '.json':
            with open(Path(data_source), 'r', encoding='utf-8') as f:
                json_data = json.load(f)
            self.teams         = json_data['Teams']
            self.objectives    = json_data['Objectives']
            self.player_scores = json_data['PlayerScores']
            self.display_slots = json_data['DisplaySlots']
        if Path(data_source).suffix == '.dat':
            from nbt.nbt import NBTFile
            self.nbt_data: NBTFile = NBTFile(data_source, 'rb')['data']

            self.teams = {}
            for team in tqdm(self.nbt_data['Teams'], disable=not show_progress):
                self.teams[team['Name'].value] = {
                    'DeathMessageVisibility': team['DeathMessageVisibility'].value,
                    'TeamColor':              team['TeamColor'].value,
                    'SeeFriendlyInvisibles':  team['SeeFriendlyInvisibles'].value,
                    'CollisionRule':          team['CollisionRule'].value,
                    'AllowFriendlyFire':      team['AllowFriendlyFire'].value,
                    'MemberNamePrefix':       team['MemberNamePrefix'].value,
                    'NameTagVisibility':      team['NameTagVisibility'].value,
                    'MemberNameSuffix':       team['MemberNameSuffix'].value,
                    'Players':                [player.value for player in team['Players']],
                    'DisplayName':            {'json_dict': json.loads(team['DisplayName'].value), 'json_string': team['DisplayName'].value}
                    }
            self.objectives = {}
            for obj in tqdm(self.nbt_data['Objectives'], disable=not show_progress):
                self.objectives[obj['Name'].value] = {
                        'CriteriaName': obj['CriteriaName'].value,
                        'RenderType':   obj['RenderType'].value,
                        'DisplayName':  {'json_dict': json.loads(obj['DisplayName'].value), 'json_string': obj['DisplayName'].value}
                    }
            self.display_slots = {slot:obj.value for slot,obj in tqdm(self.nbt_data['DisplaySlots'].items(), disable=not show_progress)}
            self.player_scores = {}
            for entry in tqdm(self.nbt_data['PlayerScores'], disable=not show_progress):
                player_name: str = entry['Name'].value

                # Skip this player if they're in the blacklist or not in the whitelists
                if self.player_blacklist and (player_name in self.player_blacklist):
                    continue
                if (self.player_whitelist and (player_name not in self.player_whitelist)) and \
                    (include_dot_names and not player_name.startswith('.')):
                    continue

                objective: str = entry['Objective'].value
                score: int = entry['Score'].value
                # Make an entry for this player if it doesn't exist
                if player_name not in self.player_scores:
                    self.player_scores[player_name] = {}
                self.player_scores[player_name][objective] = score

    def __repr__(self) -> str:
        description: list[str] = []
        for key, value in vars(self).items():
            if key == 'nbt_data':
                continue
            num = len(value)
            empty = '[]' if isinstance(value, list) else '{}'
            description.append(f'{key}={str(num) + f' {'items' if num > 1 else 'item'}...' if num > 0 else empty}')
        return f'Scoreboard({', '.join(description)})'

    def to_dict(self) -> dict:
        """Return a dictionary of this Scoreboard data."""
        return {
            'Teams': self.teams,
            'Objectives': self.objectives,
            'PlayerScores': self.player_scores,
            'DisplaySlots': self.display_slots
        }

    def get_objective_name(self, objective: str, json_string: bool=False):
        """Shorthand for retrieving the 'DisplayName' attribute of the given objective."""
        name_info: dict = self.objectives[objective]['DisplayName']
        return name_info['json_dict']['text'] if not json_string else name_info['json_string']

    def get_objective_scores(self, target_objective: str, ascending: bool=False) -> list[tuple[str, int]]:
        """Returns a list of tuples containing the player name and player score associated with the given objective,
        by default sorted from highest to lowest.

        :param objective: The objective name to retrieve scores for.
        :param ascending: If true, will instead return score rankings from lowest to highest."""
        unsorted_scores = {}
        # Iterate through player's set of objectives
        for player, objectives in self.player_scores.items():
            # Establish a dict entry for them, search through every objective
            unsorted_scores[player] = {}
            for obj, score in objectives.items():
                # If this is our target then store it, and break the loop
                if obj == target_objective:
                    unsorted_scores[player] = score
                    break
            # If nothing was found, don't include an empty dict in the results
            if not unsorted_scores[player]:
                unsorted_scores.pop(player)
        # Sort them highest to lowest, reverse if specified
        # This lambda sorts it by values instead of keys. I don't know how it works, that's just what came up
        return sorted(unsorted_scores.items(), key=lambda x: x[1], reverse=not ascending)

def main():
    if len(sys.argv) < 2:
        print('If running this script directly, you need to supply a file path to either a DAT or JSON file as an argument.')
        input('Press ENTER to quit.')
        return

    infile: Path = Path(sys.argv[1])

    if (filter_type := input('Filter? (w for whitelist, b for blacklist, n for none) ').lower()) not in ['w', 'b', 'n']:
        print('Invalid response.')
        input('Press ENTER to quit.')
        return

    q: str = input('Provide a list of names to filter, or a path to a JSON file. ')
    filter_contents: Path | list[str] = Path(q) if q.endswith('.json') else [i.strip() for i in q.split(',')]
    del q

    kwargs: dict = {}
    if filter_type != 'n':
        kwargs['player_whitelist' if filter_type == 'w' else 'player_blacklist'] = filter_contents

    sb: Scoreboard = Scoreboard(infile, **kwargs)

    outfile: str = f'output_{infile}.json'

    with open(outfile, 'w', encoding='utf-8') as f:
        json.dump(sb.to_dict(), f)

    print(f'Saved to {outfile}')
    input('Press ENTER to quit.')
    return

if __name__ == '__main__':
    main()
